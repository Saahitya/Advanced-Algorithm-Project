1) Choosing the Search Area: The First step is to define the search area we are interested in. The search area should be optimal, such that it can give us a good and meaningful visualization in limited time. The simplest way is to choose among different cities/districts. If the area of interest is smaller than a district, we can choose a center and a radius to define the search area and find all the accidents that have occurred in that circle.

2) Weighing: The second step is weighing. Some accidents could have been more severe than the other, hence weighing these accidents becomes an important step to find hotspots. First, we choose the attributes for weighing. Here, we have chosen the severity of the accident as the weighting parameter. Other options could be the number of casualties etc. There is no particular rule for assigning weights, it depends on the user's view.

3) KDE / Weighted KDE: KDE is a smoothing problem. In this method, a kernel function is placed on every crash point resulting in a smooth, individual and continuos crash density surface. Now, a grid of cells is overlapped on the search area. For a given cell, density is estimated by summing the overlapping density surface resulted from each crash point. This procedure is repeated for all the cells in the grid, which results in hotspots. In the case of weighted KDE, the crash points with high severity are given higher scores. KDE was done using kde2d function from package MASS. This function takes three parameters, latitude, longitude and n. 'n' defines the number of cells in the grid, the plot gets smoother by increasing the value of n. For weighted KDE, kde2d.weighted function was used. This function requires an additional parameter - weights (note: both kde2d and kde2d.weighted do not accept NA values. Hence, the rows with NA in latitude/longitude were excluded from the density estimation). Both the functions redefine the search area into an n x n square and the output is a matrix of size n x n where each value is the score of that cell.

4) Comparison:  The plots of weighted vs normal KDE were compared with image function. Different weighing measures, for different values of n were explored.

5) Constructing polygons, final Visualization: To visualize the output of KDE, we have to create polygons of hotspots, to achieve this, first, contours were created around different levels of hotspots using contourLines function. These contours were then bound into spatial polygons using SpatialPolygons function of package sp. Finally, the polygons generated were plotted on leaflet maps. Leaflet provides free open street maps. The same procedure can be applied to google maps with qmap function. Unlike leaflet, google maps is not entirely free and requires enabling API services from google cloud platform.
